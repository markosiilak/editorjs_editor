<?php

use Drupal\Core\Field\FieldItemListInterface;
use Drupal\Core\Render\BubbleableMetadata;
use Drupal\editorjs_editor\Service\EditorJsRenderer;

/**
 * Implements hook_entity_view_alter().
 */
function editorjs_editor_entity_view_alter(array &$build, \Drupal\Core\Entity\EntityInterface $entity, \Drupal\Core\Entity\Display\EntityViewDisplayInterface $display) {
  // Apply to all entity types (nodes, comments, products, etc.).

  $renderer = \Drupal::service('editorjs_editor.renderer');
  $is_teaser = $display->getMode() === 'teaser';

  // Most entity view builders place fields under a 'content' container.
  $container =& $build;
  if (isset($build['content']) && is_array($build['content'])) {
    $container =& $build['content'];
  }

  foreach ($entity->getFields() as $fieldName => $items) {
    if (!$items instanceof FieldItemListInterface) {
      continue;
    }

    // Target long text fields that likely contain JSON from Editor.js.
    $definition = $items->getFieldDefinition();
    $type = $definition->getType();
    if (!in_array($type, ['text_long', 'text_with_summary', 'string_long'], TRUE)) {
      continue;
    }

    if (!isset($container[$fieldName]) || !is_array($container[$fieldName])) {
      continue;
    }

    // Transform each item if the value appears to be JSON with blocks.
    $processedAny = FALSE;
    foreach ($container[$fieldName] as $delta => &$element) {
      // Only process numeric deltas that are render arrays.
      if (!is_int($delta) || !is_array($element)) {
        continue;
      }

      // Prefer reading the raw field value (JSON) from the entity, not the
      // rendered text, to avoid filters altering JSON.
      $candidate = NULL;
      $item = $items->get($delta);
      if ($item) {
        $values = $item->getValue();
        if (isset($values['value'])) {
          $candidate = (string) $values['value'];
        }
      }
      // Fallback to rendered keys if necessary.
      if ($candidate === NULL) {
        if (isset($element['#text'])) {
          $candidate = (string) $element['#text'];
        }
        elseif (isset($element['#markup'])) {
          $candidate = (string) $element['#markup'];
        }
        else {
          continue;
        }
      }

      $candidate = trim($candidate);
      $jsonString = editorjs_editor_extract_json_string($candidate);
      if ($jsonString === NULL) {
        continue;
      }

      $decoded = json_decode($jsonString, true);
      if (json_last_error() !== JSON_ERROR_NONE) {
        continue;
      }

      $html = '';
      if (is_array($decoded) && !empty($decoded['blocks']) && is_array($decoded['blocks'])) {
        // Editor.js structure.
        $html = $is_teaser ? $renderer->renderFirstParagraph($decoded) : $renderer->render($decoded);
        if ($html === '' && $is_teaser) {
          // Fallback to full render if no paragraph found.
          $html = $renderer->render($decoded);
        }
      }
      else {
        // Generic JSON pretty print as a fallback.
        $pretty = htmlspecialchars(json_encode($decoded, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE), ENT_QUOTES, 'UTF-8');
        $html = '<pre class="prose max-w-none whitespace-pre-wrap">' . $pretty . '</pre>';
      }
      if ($html === '') {
        continue;
      }

      // Replace with safe markup.
      $element = [
        '#type' => 'inline_template',
        '#template' => '{{ html|raw }}',
        '#context' => ['html' => $html],
        '#editorjs_data' => $jsonString, // Store original JSON for inline editing
        '#editorjs_field_id' => $fieldName,
        '#editorjs_entity_id' => $entity->id(),
        '#editorjs_entity_type' => $entity->getEntityTypeId(),
        '#attached' => [
          'library' => ['editorjs_editor/editorjs.inline'],
        ],
      ];

      $processedAny = TRUE;
      // Ensure cacheability bubbles properly.
      BubbleableMetadata::createFromRenderArray($element)->applyTo($element);
    }

    // Some formatters render without numeric deltas. Handle that case too.
    if (!$processedAny) {
      $element =& $container[$fieldName];
      if (!is_array($element)) {
        continue;
      }
      // Prefer raw field value (delta 0) when available.
      $candidate = NULL;
      $first = $items->first();
      if ($first) {
        $values = $first->getValue();
        if (isset($values['value'])) {
          $candidate = (string) $values['value'];
        }
      }
      if ($candidate === NULL) {
        if (isset($element['#text'])) {
          $candidate = (string) $element['#text'];
        }
        elseif (isset($element['#markup'])) {
          $candidate = (string) $element['#markup'];
        }
      }
      if (!is_string($candidate)) {
        continue;
      }
      $candidate = trim($candidate);
      $jsonString = editorjs_editor_extract_json_string($candidate);
      if ($jsonString === NULL) {
        continue;
      }
      $decoded = json_decode($jsonString, TRUE);
      if (json_last_error() !== JSON_ERROR_NONE) {
        continue;
      }
      $html = '';
      if (is_array($decoded) && !empty($decoded['blocks']) && is_array($decoded['blocks'])) {
        $html = $is_teaser ? $renderer->renderFirstParagraph($decoded) : $renderer->render($decoded);
        if ($html === '' && $is_teaser) {
          $html = $renderer->render($decoded);
        }
      }
      else {
        $pretty = htmlspecialchars(json_encode($decoded, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE), ENT_QUOTES, 'UTF-8');
        $html = '<pre class="prose max-w-none whitespace-pre-wrap">' . $pretty . '</pre>';
      }
      if ($html === '') {
        continue;
      }
      $element = [
        '#type' => 'inline_template',
        '#template' => '{{ html|raw }}',
        '#context' => ['html' => $html],
        '#editorjs_data' => $jsonString, // Store original JSON for inline editing
        '#editorjs_field_id' => $fieldName,
        '#editorjs_entity_id' => $entity->id(),
        '#editorjs_entity_type' => $entity->getEntityTypeId(),
        '#attached' => [
          'library' => ['editorjs_editor/editorjs.inline'],
        ],
      ];
      BubbleableMetadata::createFromRenderArray($element)->applyTo($element);
    }
  }
}


/**
 * Attempt to extract a JSON object string from possibly wrapped text.
 */
function editorjs_editor_extract_json_string(string $text): ?string {
  $candidate = trim($text);
  if ($candidate === '') {
    return NULL;
  }

  // Try direct decode.
  $decoded = json_decode($candidate, true);
  if (json_last_error() === JSON_ERROR_NONE && (is_array($decoded) || is_object($decoded))) {
    return $candidate;
  }

  // Decode HTML entities and try again.
  $unescaped = html_entity_decode($candidate, ENT_QUOTES | ENT_HTML5, 'UTF-8');
  if ($unescaped !== $candidate) {
    $decoded = json_decode($unescaped, true);
    if (json_last_error() === JSON_ERROR_NONE && (is_array($decoded) || is_object($decoded))) {
      return $unescaped;
    }
  }

  // Strip tags and try again (e.g., wrapped in <p> ... </p>).
  $stripped = trim(strip_tags($candidate));
  if ($stripped !== $candidate) {
    $decoded = json_decode($stripped, true);
    if (json_last_error() === JSON_ERROR_NONE && (is_array($decoded) || is_object($decoded))) {
      return $stripped;
    }
  }

  // Fallback: grab substring between first '{' and last '}'.
  $start = strpos($candidate, '{');
  $end = strrpos($candidate, '}');
  if ($start !== false && $end !== false && $end > $start) {
    $sub = substr($candidate, $start, $end - $start + 1);
    $decoded = json_decode($sub, true);
    if (json_last_error() === JSON_ERROR_NONE && (is_array($decoded) || is_object($decoded))) {
      return $sub;
    }
  }

  return NULL;
}

/**
 * Implements hook_entity_presave().
 */
function editorjs_editor_entity_presave(\Drupal\Core\Entity\EntityInterface $entity) {
  // Only process comment entities
  if ($entity->getEntityTypeId() !== 'comment') {
    return;
  }

  // Check if the comment has a body field with EditorJS content
  if (!$entity->hasField('comment_body')) {
    return;
  }

  $body_field = $entity->get('comment_body');
  if ($body_field->isEmpty()) {
    return;
  }

  $body_value = $body_field->getValue();
  if (empty($body_value[0]['value'])) {
    return;
  }

  $body_text = trim($body_value[0]['value']);
  
  // Check if the content looks like EditorJS JSON
  if (empty($body_text) || !($body_text[0] === '{' || $body_text[0] === '[')) {
    return;
  }

  // Try to decode as JSON
  $decoded = json_decode($body_text, TRUE);
  if (json_last_error() !== JSON_ERROR_NONE) {
    return;
  }

  // Check if it has EditorJS structure
  if (!is_array($decoded) || !isset($decoded['blocks']) || !is_array($decoded['blocks'])) {
    return;
  }

  // Extract first paragraph text for the subject
  $renderer = \Drupal::service('editorjs_editor.renderer');
  $first_paragraph_html = $renderer->renderFirstParagraph($decoded);
  
  if (!empty($first_paragraph_html)) {
    // Strip HTML tags to get plain text
    $plain_text = strip_tags($first_paragraph_html);
    $plain_text = trim($plain_text);
    
    // Limit to 64 characters (Drupal's comment subject field limit)
    if (strlen($plain_text) > 64) {
      $plain_text = substr($plain_text, 0, 61) . '...';
    }
    
    // Set the subject field if it's empty or contains JSON-like content
    $current_subject = $entity->get('subject')->value;
    if (empty($current_subject) || (strpos($current_subject, '{') === 0)) {
      $entity->set('subject', $plain_text);
    }
  }
}

/**
 * Implements hook_entity_load().
 */
function editorjs_editor_entity_load(array $entities, $entity_type_id) {
  // Only process comment entities
  if ($entity_type_id !== 'comment') {
    return;
  }

  foreach ($entities as $entity) {
    // Check if the comment subject contains JSON metadata
    $subject_field = $entity->get('subject');
    $subject = $subject_field->isEmpty() ? '' : $subject_field->value;
    if (!empty($subject) && strpos($subject, '{') === 0) {
      // Check if the comment has a body field with EditorJS content
      if (!$entity->hasField('comment_body')) {
        continue;
      }

      $body_field = $entity->get('comment_body');
      if ($body_field->isEmpty()) {
        continue;
      }

      $body_value = $body_field->getValue();
      if (empty($body_value[0]['value'])) {
        continue;
      }

      $body_text = trim($body_value[0]['value']);
      
      // Check if the content looks like EditorJS JSON
      if (empty($body_text) || !($body_text[0] === '{' || $body_text[0] === '[')) {
        continue;
      }

      // Try to decode as JSON
      $decoded = json_decode($body_text, TRUE);
      if (json_last_error() !== JSON_ERROR_NONE) {
        continue;
      }

      // Check if it has EditorJS structure
      if (!is_array($decoded) || !isset($decoded['blocks']) || !is_array($decoded['blocks'])) {
        continue;
      }

      // Extract first paragraph text for the subject
      $renderer = \Drupal::service('editorjs_editor.renderer');
      $first_paragraph_html = $renderer->renderFirstParagraph($decoded);
      
      if (!empty($first_paragraph_html)) {
        // Strip HTML tags to get plain text
        $plain_text = strip_tags($first_paragraph_html);
        $plain_text = trim($plain_text);
        
        // Limit to 64 characters (Drupal's comment subject field limit)
        if (strlen($plain_text) > 64) {
          $plain_text = substr($plain_text, 0, 61) . '...';
        }
        
        // Update the subject field
        $entity->set('subject', $plain_text);
        $entity->save();
      }
    }
  }
}

/**
 * Implements hook_preprocess_field().
 */
function editorjs_editor_preprocess_field(&$variables) {
  $field_name = $variables['field_name'];
  $field_type = $variables['element']['#field_type'] ?? '';
  
  // Only process text fields that might contain EditorJS content
  if (!in_array($field_type, ['text_long', 'text_with_summary', 'string_long'], TRUE)) {
    return;
  }
  
  // Get the field items
  $items = $variables['items'];
  if (empty($items)) {
    return;
  }
  
  $renderer = \Drupal::service('editorjs_editor.renderer');
  $processed = FALSE;
  
  foreach ($items as $delta => $item) {
    // In preprocess_field, $item is an array, not an object
    $text = $item['content']['#text'] ?? $item['content']['#markup'] ?? '';
    
    if (empty($text)) {
      continue;
    }
    
    // Check if the content looks like EditorJS JSON
    $trimmed = trim($text);
    if ($trimmed === '' || !($trimmed[0] === '{' || $trimmed[0] === '[')) {
      continue;
    }
    
    // Try to decode as JSON
    $decoded = json_decode($trimmed, TRUE);
    if (json_last_error() !== JSON_ERROR_NONE) {
      continue;
    }
    
    // Check if it has EditorJS structure
    if (!is_array($decoded) || !isset($decoded['blocks']) || !is_array($decoded['blocks'])) {
      continue;
    }
    
    // Render as EditorJS content
    $html = $renderer->render($decoded);
    if ($html === '') {
      continue;
    }
    
    // Replace the item content and add inline data attributes so Twig wrapper can read them
    $variables['items'][$delta]['content'] = [
      '#type' => 'inline_template',
      '#template' => '{{ html|raw }}',
      '#context' => ['html' => $html],
      '#editorjs_data' => json_encode($decoded),
      '#editorjs_field_id' => $field_name,
      '#editorjs_entity_id' => $variables['element']['#object']->id() ?? NULL,
      '#editorjs_entity_type' => $variables['element']['#object']->getEntityTypeId() ?? NULL,
      '#attached' => [
        'library' => ['editorjs_editor/editorjs.inline'],
      ],
    ];
    
    $processed = TRUE;
  }
  
  if ($processed) {
    // Clear the original field content to avoid duplication
    $variables['items'] = array_filter($variables['items'], function($item) {
      return isset($item['content']);
    });
  }
}

/**
 * Implements hook_page_attachments_alter().
 */
function editorjs_editor_page_attachments_alter(array &$attachments) {
  // Add CSRF tokens for inline editing and image uploads
  $csrf_token_service = \Drupal::service('csrf_token');
  $attachments['#attached']['drupalSettings']['csrf_token'] = $csrf_token_service->get('editorjs-inline-save');
  $attachments['#attached']['drupalSettings']['csrf_token_image_upload'] = $csrf_token_service->get('editorjs-image-upload');
  $attachments['#attached']['drupalSettings']['csrf_token_image_url'] = $csrf_token_service->get('editorjs-image-url');
}

